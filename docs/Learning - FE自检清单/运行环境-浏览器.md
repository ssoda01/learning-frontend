---
sidebar_position: 9
---

# 运行环境篇 - 浏览器API
我们需要理清语言和环境的关系：

> ECMAScript描述了JavaScript语言的语法和基本对象规范
> 浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口
> Node也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API

## 浏览器API

1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性


2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性


3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)


4.浏览器海量数据存储、操作性能优化


5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理


6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库


7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型


8.浏览器提供的几种存储机制、优缺点、开发中正确的选择


9.浏览器跨标签通信

浏览器原理


1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分


2.请求数据到请求结束与服务器进行了几次交互


3.可详细描述浏览器从输入URL到页面展现的详细过程


4.浏览器解析HTML代码的原理，以及构建DOM树的流程


5.浏览器如何解析CSS规则，并将其应用到DOM树上


6.浏览器如何将解析好的带有样式的DOM树进行绘制


7.浏览器的运行机制，如何配置资源异步同步加载


8.浏览器回流与重绘的底层原理，引发原因，如何有效避免


9.浏览器的垃圾回收机制，如何避免内存泄漏


10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案
----
## AI答案
1. 各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分

不同浏览器使用不同的JavaScript引擎，主要分为以下几种：

- Chrome 和 Opera 使用的是 V8 引擎
- Safari 和 iOS Safari 使用的是 JavaScriptCore (又名 Nitro) 引擎
- Firefox 使用的是 SpiderMonkey 引擎
- Edge 和 IE 使用的是 Chakra 引擎

这些引擎之间的主要差异是它们的性能和实现代码的差异。比如，V8 引擎在性能方面表现卓越，而SpiderMonkey 引擎则在一些 JavaScript 是非常高级的方面表现良好。在代码中进行区分这些引擎的方式可以是检测某些特定对象是否存在，比如 window.chrome 和 window.mozInnerScreenX，来推断当前浏览器使用的是哪种引擎。

2. 请求数据到请求结束与服务器进行了几次交互

浏览器和服务器之间的请求和响应通常涉及到多次交互。常见的情况通常涉及以下几个步骤：

- 浏览器向服务器发送请求；
- 服务器返回响应消息及其所需资源的头信息，包括资源的大小和类型；
- 浏览器根据响应头信息向服务器请求所需资源；
- 服务器返回请求的资源。

在这个过程中，实际进行的交互次数取决于网络延迟和资源的大小。

3. 可详细描述浏览器从输入URL到页面展现的详细过程

1. 输入 URL 到解析 DNS：当输入URL时，浏览器会先检查本地缓存中是否有对应的 DNS 记录，如果没有则通过系统调用等方式向本地 DNS 服务器发起请求。

2. DNS 解析到建立 TCP 连接：如果本地 DNS 服务器找到对应的域名，则会将解析出的对应 IP 地址返回给浏览器。接着，浏览器会使用该 IP 地址，通过3次握手建立 TCP 连接。

3. TCP 连接建立到发送 HTTP 请求：TCP 连接成功之后，浏览器就可以向服务器发送 HTTP 请求了。HTTP 请求报文中包含了请求方法、请求头和请求体等内容。

4. 服务器接收请求到返回 HTML：服务器收到 HTTP 请求之后，会解析出相应的请求信息，然后查询所需的HTML等资源，并生成相应的响应返回给浏览器。

5. 浏览器解析 HTML 到构建 DOM 树: 浏览器接收到响应后，会使用HTML解析器（HTML Parser）解析HTML代码，并构建出DOM树。

6. 构建 DOM 树到CSS 解析: CSS代码会被下载并解析，解析后的CSS规则将被保存在内部的数据结构中。

7. CSS 解析到构建渲染树: 浏览器会将DOM树和CSS规则合并，生成一个渲染树（Render Tree）。

8. 构建渲染树到布局: 浏览器会根据渲染树中的信息进行布局计算，计算出每个元素在屏幕中所占的精确位置和大小等信息。

9. 布局到绘制：布局计算完成之后，浏览器开始向屏幕绘制页面了。

4. 浏览器解析 HTML 代码的原理，以及构建 DOM 树的流程

浏览器解析 HTML 的大致流程如下：

1. 浏览器收到 HTML 字符流并扫描搜索起始标签；
2. 一旦找到底一个起始标签，就创建一个对应的 DOM 节点对象；
3. 然后解析其后的属性，为节点设置相应属性；
4. 浏览器会继续扫描 HTML 中的下一个标签及其内容，一旦找到，就创建新的节点，并将其挂在相应 DOM 节点的树形结构中，形成一个 DOM 树。

5. 浏览器如何解析 CSS 规则，并将其应用到 DOM 树上

浏览器解析 CSS 规则的大致流程如下：

1. 浏览器将 CSS 文件中的字符流转换成一个个的令牌（Token），一般是通过词法分析器进行转换；
2. 浏览器将由令牌组成的流解析成层叠样式表（StyleSheet）结构；
3. 解析后浏览器拥有一些对象，这些对象表示了解析出来的样式规则和定义的规则树（Rule Tree）；
4. 在渲染页面时，浏览器会遍历 DOM 树和次级的 CSSOM树，并将它们合并成一个渲染树（Render Tree）；
5. 渲染树中的每个节点都表示一个可见元素（之所以叫渲染树是因为它包含着浏览器渲染页面的结构）；
6. 每个渲染器都包含着指向对应 DOM 节点和在应用 CSS 规则后计算得出的样式信息的指针；
7. 渲染器将开始在堆栈上应用样式信息，当某条规则需要覆盖一个之前的规则时，渲染器会对自己进行重写；

6. 浏览器如何将解析好的带有样式的 DOM 树进行绘制

浏览器将解析好的带有样式的 DOM 树进行绘制的大致流程如下：

1. 首先，浏览器将 DOM 树转换为渲染树。
2. 然后，浏览器通过计算渲染树中每个节点在屏幕上的准确位置和大小，来确定应该在屏幕上画出什么。
3. 浏览器根据渲染树开始绘制页面，并将页面布局和绘制过程分别放在不同的模块中完成，以便交替发生，提高效率。
4. 浏览器在绘制时，使用一些简单的绘制操作（如绘制线条、矩形、圆形等），来绘制页面中的每个可见元素。
5. 在完成页面绘制后，浏览器将它们显示在屏幕上。

7. 浏览器的运行机制，如何配置资源异步同步加载

浏览器的运行机制主要包括两个方面：

1. 渲染引擎：负责解析 HTML、CSS 和 JavaScript，并将其转换成可视化内容；
2. JavaScript 引擎：负责解析和执行 JavaScript 代码。

在加载网页资源时，浏览器可以使用以下两种方式：

1. 同步加载：浏览器会在加载并解析当前资源时阻塞页面其他操作，直到资源加载完毕并执行完毕后，才会继续执行页面其他操作。
2. 异步加载：浏览器在不阻塞当前页面操作的情况下，通过异步加载方式加载和执行某些资源，以提高页面的性能。

可以通过 `async` 和 `defer` 属性来实现异步加载：

- `async`：异步加载并执行脚本，可以在下载脚本时继续解析页面，但是脚本的执行顺序不受控制。
- `defer`：异步加载脚本，但是脚本会在文档解析完毕之后按照顺序执行。

8. 浏览器回流与重绘的底层原理，引发原因，如何有效避免

重绘和回流只会在容器中的当然情况下才会发生，这些情况包括以下几种：

1. 添加/删除 DOM 元素；
2. 修改 DOM 元素的 CSS 属性；
3. 改变元素的内容；
4. 改变元素的尺寸或者位置；
5. 改变浏览器窗口大小。

以下是回流和重绘的区别和如何避免的几个方法：

- 回流：重新渲染页面的一部分以使其在任何特定时间反映的内容是最新的。避免：可以通过减少 DOM 操作的数量、合并操作、使用 CSS3 中的 transform 或 opacity 属性，避免频繁获取元素的布局信息等方式来避免。
- 重绘：给元素添加颜色或改变边框大小，这将导致浏览器重新把元素的像素全部重新绘制一遍。避免：可以通过使用 CSS3 选择器或者样式批量设置属性，通过减少渲染节点或者最小化 DOM 层级，以避免不必要的重绘。

9. 浏览器的垃圾回收机制，如何避免内存泄漏

浏览器通过垃圾回收器（Garbage Collector）定期清理和释放不再被使用的内存。垃圾回收器会识别那些已经不再需要的变量，并将它们从内存中删除，从而释放内存。

避免内存泄漏的方法如下：

1. 避免全局变量：尽量避免定义全局变量，因为全局变量在页面关闭后仍会保留在内存中。
2. 使用闭包：使用闭包有助于确保变量仅在必要时被声明，从而尽量减少变量的生命周期。
3. 避免使用循环引用：如果对象之间相互引用，垃圾回收器可能无法识别哪些对象应该被删除。
4. 其他一些技巧：比如，减少使用内存消耗大的类型，及时清除事件处理函数，避免使用过多的 setTimeout 和 setInterval 等都有一定帮助。

10. 浏览器采用的缓存方案，如何选择和控制合适的缓存方案

浏览器通常会采用以下两种类型的缓存方案：

1. 强缓存：在强缓存存在时，浏览器会直接从缓存中加载资源，而不是再向服务器发送请求。
2. 协商缓存：在协商缓存中，浏览

Node


1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等


2.掌握一种Node开发框架，如Express，Express和Koa的区别


3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理


4.Node的底层运行原理、和浏览器的异同


5.Node事件驱动、非阻塞机制的实现原理