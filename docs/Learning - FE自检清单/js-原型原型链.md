---
sidebar_position: 3
---

# JS篇 - 原型&原型链

## 1.理解原型设计模式以及JavaScript中的原型规则
## 2.instanceof的底层实现原理，手动实现一个instanceof
## 4.实现继承的几种方式以及他们的优缺点
## 5.至少说出一种开源项目(如Node)中应用原型继承的案例
## 6.可以描述new一个对象的详细过程，手动实现一个new操作符
## 7.理解es6 class构造以及继承的底层实现原理

---
# AI版回答

1. 原型设计模式是一种创建对象的模式，它通过使用原型对象来减少对象的创建，提高性能。在JavaScript中，每个对象都有一个原型对象，可以通过Object.getPrototypeOf()方法来获取。原型规则定义了对象如何查找属性和方法，如果对象本身没有该属性或方法，就会在其原型对象上查找，直到找到或者到达原型链的顶端。
2. instanceof的底层实现原理是通过判断对象的原型链中是否有构造函数的prototype属性，来确定对象是否是该构造函数的实例。手动实现一个instanceof可以通过遍历对象的原型链，并判断原型链中是否有指定的构造函数的prototype属性。
3. 实现继承的几种方式包括原型链继承、构造函数继承、组合继承、寄生式继承和寄生组合式继承。它们的优缺点如下：
- 原型链继承：易于实现，可以继承原型上的属性和方法，但子类实例共享父类实例属性和方法，且无法在子类实例中传入参数。
- 构造函数继承：可以传入参数，每个实例都有自己的属性和方法，但无法继承原型上的属性和方法。
- 组合继承：结合了原型链继承和构造函数继承的优点，可继承原型上的属性和方法，每个实例都有自己的属性和方法，但会调用两次父类构造函数。
- 寄生式继承：与原型式继承类似，通过封装创建对象的函数并返回一个新对象来实现继承，但不能使用 instanceof 判断继承关系。
- 寄生组合式继承：通过将父类的原型赋值给中间对象，再将中间对象的构造函数赋值给子类的原型，可以避免调用两次父类构造函数的问题。
4. Node.js中应用原型继承的案例包括流(Stream)、事件(EventEmitter)和HTTP模块，它们都是通过继承Node.js核心模块的原型来实现的。
5. new一个对象的详细过程包括：创建一个空对象，将这个空对象的__proto__指向构造函数的prototype，执行构造函数并传入参数，如果构造函数返回一个对象，则返回该对象，否则返回创建的空对象。手动实现一个new操作符可以通过使用Object.create()方法创建一个空对象，并将该对象的原型指向构造函数的prototype；使用apply()方法调用构造函数，并传入参数；如果构造函数返回一个对象，则返回该对象，否则返回创建的空对象。
6. es6 class构造以及继承的底层实现原理与传统的原型继承类似，都是通过原型链来实现继承。class构造函数中定义的属性和方法会被添加到构造函数的prototype对象上，子类继承时可以通过super关键字调用父类的构造函数和方法。但实际上，es6 class只是一种简化的语法糖，内部还是使用原型继承来实现的。