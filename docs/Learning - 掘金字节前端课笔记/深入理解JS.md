# 深入理解JS

## 浏览器进程
- Browser进程
- GPU进程
- 渲染进程
    - GUI线程
    - JS线程
        - GUI和JS是互斥的
    - 事件触发线程
    - 定时器触发线程
    - 网络线程
- 插件进程、网络进程

## JS基本概念

### 静态作用域

通过静态作用域可以预测代码在执行过程中如何查找标识符
（js也是词法作用域，对应词法环境）

- 全局作用域 var
- 函数作用域 function
- 块级作用域 大括号包起来
    
    ```html
    example:
    {
        const company = 'aaa'
        console.log('11',company)
    }
    console.log('22',company)
    
    // output
    VM661:3 11 aaa
    VM661:5 Uncaught ReferenceError: company is not defined
    ```
    

JS是怎么执行的

【源代码】

通过词法分析 语法分析 转换为

【AST】，还会创建一个【执行上下文】

将AST转换为【字节码】，字节码逐行解释执行生成的【机器码】

因为汇编里，写个1+2的机器码代码量都很多，一次性都转完会占很多内存，所以v8会先转成字节码，逐行执行。然后还要<JIT编译优化的阶段>把常用的相同的代码当成热代码，直接把它的机器码存起来直接用。

重点讲下执行上下文

JS引擎解析到可执行代码片段时（通常是函数调用）的时候，进行的一些准备工作，就叫执行上下文。

执行上下文包括：

- 变量环境（→ Outer 指向外部变量环境的指针）
- 词法环境
- This
- 可执行代码

执行上下文的种类：

- 全局：代码开始执行时就被创建并被压入执行栈的栈底，每个生命周期只有一份
- 函数：函数执行结束时从栈弹出
- eval

创建执行上下文：

- 绑定This
- 创建词法环境
- 创建变量环境

变量环境里有一个指向外部函数执行上下文的指针，形成了作用域链

通过Outer（指向外部变量环境的指针）一层一层往外找变量的时候，就是作用域链。

this和执行上下文绑定

## JS进阶知识点

### 闭包

return一个闭包，闭包指向了堆里的地址指向的变量，因此这个变量不会被回收。闭包本质就是没有被回收的对象。

### This

- 普通函数的this永远指向window，不管嵌套还是闭包（在v8里是global）
- 对象调用
    - 指向对象
        - 用apply和call可以改变指向
    - 先赋值再调用
- 构造函数
    - new Func(), 创建了临时对象
    - 将this指向临时对象
    - 执行构造函数
    - 返回临时对象

### 垃圾回收

堆：

- 新生代空间 1m-8m
    - 对象区域：放活跃的变量
        1. 垃圾标记（标记处对象区的活跃数据）
        2. 对象赋值（把活跃的数据复制到空闲区）
        3. 区域反转（把空闲区变成对象区，把对象区域变成空闲区（=清空掉），完成垃圾回收）
    - 空闲区域
- 老生代
    - 老生代的数据怎么来的
        - 数据很大，新生代放不下，直接放到老生代
        - 再新生代里经历过了2轮垃圾回收
    - 垃圾回收过程
        - 标记
        - 清除被标记的东西
        - 内存不连续了，没有地方分配，于是整理碎片
        - 因为老生代空间很大，标记清除很费时。而且标记清除的时候js是不能继续执行的。所以主垃圾回收器会分成一个个碎片任务。

### 事件循环

微任务

宏任务